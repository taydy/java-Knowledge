# 输入输出设备

大部分的输入输出设备，有两部分组成。一个是它的接口，一个是实际的 I/O 设备。硬件设备是通过接口，用接口连接到总线上，再通过总线和 CPU 通信。

接口本身就是一块电路板。CPU 其实不是和实际的硬件设备打交道，而是和这个接口电路板打交道。我们平时说的，设备里面有三类寄存器(**状态寄存器(Status Register)、 命令寄存器(Command Register) 以及数据寄存器(Data Register)**)，其实都在这个设备的接口电路上，而不在实际的设备上。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5941v024j30ln0fxdgw.jpg)

把接口和实际设备分离，这个做法实际上来自于计算机走向**开放架构**的时代。

当我们要对计算机升级，我们不会扔掉旧的计算机，直接买一台全新的计算机，而是可以单独升级硬盘这样的设备。我们把老硬盘从接口上拿下来，换一个新的上去就好了。各种输入输出设备的制造商，也可以根据接口的控制协议，来设计和制造硬盘、鼠标、键盘、打印机乃至其他种种外设。正是这样的分工协作，带来了 PC 时代的繁荣。

如果你用的是 Windows 操作系统，你可以打开设备管理器，里面有各种各种的 Devices（设备）、Controllers（控制器）、Adaptors（适配器）。这些，其实都是对于输入输出设备不同角度的描述。被叫作 Devices，看重的是实际的 I/O 设备本身。被叫作 Controllers，看重的是输入输出设备接口里面的控制电路。而被叫作 Adaptors，则是看重接口作为一个适配器后面可以插上不同的实际设备。

## CPU 如何控制 I/O 设备

无论是内置在主板上的接口，还是集成在设备上的接口，除了三类寄存器之外，还有对应的控制电路。正是通过这个控制电路，CPU 才能通过向这个接口电路板传输信号，来控制实际的硬件。

我们先来看一看，硬件设备上的这些寄存器有什么用。这里，我拿我们平时用的打印机作为例子。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5dmq97fbj31940u0afa.jpg)

- **数据寄存器(Date Register)** CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是“Test”，我们就要先发送一个“T”给到对应的 I/O 设备。

- **命令寄存器(Command Register)** CPU 发送一个命令，告诉打印机，要进行打印工作。这个时候，打印机里面的控制电路会做两个动作。第一个，是去设置我们的状态寄存器里面的状态，把状态设置成 not-ready。第二个，就是实际操作打印机进行打印。

- **状态寄存器(Status Register)** 告诉 CPU，现在设备已经在工作了，所以这个时候，CPU 你再发送数据或者命令过来，都是没有用的。直到前面的动作已经完成，状态寄存器重新变成了 ready 状态，我们的 CPU 才能发送下一个字符和命令。

当然，在实际情况中，打印机里通常不只有数据寄存器，还会有数据缓冲区。我们的 CPU 也不是真的一个字符一个字符这样交给打印机去打印的，而是一次性把整个文档传输到打印机的内存或者数据缓冲区里面一起打印的。不过，通过上面这个例子，相信你对 CPU 是怎么操作 I/O 设备的，应该有所了解了。

## 信号和地址

CPU 和 I/O 设备的通信，一样是通过 CPU 支持的机器指令来执行的。

计算机会把 I/O 设备的各个寄存器，以及 I/O 设备内部的内存地址，都映射到主内存地址空间来。主内存的地址空间里，会给不同的 I/O 设备预留一段一段的内存地址。CPU 想要和这些 I/O 设备通信的时候，就往这些地址发送数据。这些地址信息通过地址线来发送，而对应的数据信息通过数据线发送。

I/O 设备会监听地址线，并且在 CPU 往自己地址发送数据的时候，把对应的数据线里面传输的数据，接入到对应的设备里面的寄存器和内存里面来。CPU 无论是向 I/O 设备发送命令、查询状态还是传输数据，都可以通过这样的方式。这种方式叫做**映射 IO** (Memory-Mapped I/O，简称 MMIO)。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5e180cl4j30yx0u0422.jpg)

MMIO 并不是唯一的一种 CPU 和设备通信的方式。在有 2000 多个指令的 Intel X86 架构的计算机，有专门的 in 和 out 指令用户和 I/O 设备通信。

Intel CPU 虽然也支持 MMIO，不过它还可以通过特定的指令，来支持端口映射 I/O（Port-Mapped I/O，简称 PMIO）或者也可以叫独立输入输出（Isolated I/O）。

其实 PMIO 的通信方式和 MMIO 差不多，核心的区别在于，PMIO 里面访问的设备地址，不再是在内存地址空间里面，而是一个专门的端口（Port）。这个端口并不是指一个硬件上的插口，而是和 CPU 通信的一个抽象概念。

无论是 PMIO 还是 MMIO，CPU 都会传送一条二进制的数据，给到 I/O 设备的对应地址。设备自己本身的接口电路，再去解码这个数据。解码之后的数据呢，就会变成设备支持的一条指令，再去通过控制电路去操作实际的硬件设备。对于 CPU 来说，它并不需要关心设备本身能够支持哪些操作。它要做的，只是在总线上传输一条条数据就好了。

这个，其实也有点像我们在设计模式里面的 Command 模式。我们在总线上传输的，是一个个数据对象，然后各个接受这些对象的设备，再去根据对象内容，进行实际的解码和命令执行。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5ett7u1yj30b20clglx.jpg)

这是一张显卡在设备管理器里面的资源（Resource）信息。可以看到，里面既有 Memory Range，这个就是设备对应映射到的内存地址，也就是我们上面所说的 MMIO 的访问方式。同样的，里面还有 I/O Range，这个就是我们上面所说的 PMIO，也就是通过端口来访问 I/O 设备的地址。最后，里面还有一个 IRQ，也就是会来自于这个设备的中断信号了。

## 总结

CPU 并不是发送一个特定的操作指令来操作不同的 I/O 设备。因为如果是那样的话，随着新的 I/O 设备的发明，我们就要去扩展 CPU 的指令集了。

在计算机系统里面，CPU 和 I/O 设备之间的通信，是这么来解决的。

首先，在 I/O 设备这一侧，我们把 I/O 设备拆分成，能和 CPU 通信的接口电路，以及实际的 I/O 设备本身。接口电路里面有对应的状态寄存器、命令寄存器、数据寄存器、数据缓冲区和设备内存等等。接口电路通过总线和 CPU 通信，接收来自 CPU 的指令和数据。而接口电路中的控制电路，再解码接收到的指令，实际去操作对应的硬件设备。

而在 CPU 这一侧，对 CPU 来说，它看到的并不是一个个特定的设备，而是一个个内存地址或者端口地址。CPU 只是向这些地址传输数据或者读取数据。所需要的指令和操作内存地址的指令其实没有什么本质差别。通过软件层面对于传输的命令数据的定义，而不是提供特殊的新的指令，来实际操作对应的 I/O 硬件。

# 硬盘

## 机械硬盘

一块机械硬盘由盘面、磁头和悬臂组成。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5foq7lzoj317d0rxacb.jpg)

### 盘面 Disk Platter

盘面其实就是实际存储数据的盘片。

盘面本身通常是用的铝、玻璃或者陶瓷这样的材质做成的光滑盘片。然后，盘面上有一层磁性的涂层。我们的数据就存储在这个磁性的涂层上。盘面中间有一个受电机控制的转轴。这个转轴会控制我们的盘面去旋转。

硬盘有一个指标叫**转速**。转速是指盘面中间电机控制的转轴的旋转速度，英文单位叫 **RPM**，也就是**每分钟的旋转圈数**(Rotations Per Minute)。所谓 7200 转，指的就是一旦电脑开机供电之后，我们的硬盘就可以一直做到每分钟转上 7200 圈，也就是每秒钟 120 圈。

### 磁头 Drive Head

我们的数据并不能直接从盘面传输到总线上，而是通过磁头，从盘面上读取到，然后再通过电路信号传输给控制电路、接口，再到总线上的。

通常，我们的一个盘面上会有两个磁头，分别在盘面的正反面。盘面在正反两面都有对应的磁性涂层来存储数据，而且一块硬盘也不是只有一个盘面，而是上下堆叠了很多个盘面，各个盘面之间是平行的。每个盘面的正反两面都有对应的磁头。

### 悬臂 Actutor Arm

悬臂链接在磁头上，并且在一定范围内会去把磁头定位到盘面的某个特定的磁道（Track）上。这个磁道是怎么来呢？想要了解这个问题，我们要先看一看我们的数据是怎么存放在盘面上的。

一个盘面通常是圆形的，由很多歌同心圆组成，每个同心圆之间就是一个磁道，每个磁道都有一个编号。

一个磁道，会分成一个一个扇区（Sector）。上下平行的一个一个盘面的相同扇区，叫作一个柱面（Cylinder）。

读取数据，其实就是两个步骤。一个步骤，就是把盘面旋转到某一个位置。在这个位置上，我们的悬臂可以定位到整个盘面的某一个子区间。这个子区间的形状有点儿像一块披萨饼，我们一般把这个区间叫作**几何扇区**（Geometrical Sector），意思是，在“几何位置上”，所有这些扇区都可以被悬臂访问到。另一个步骤，就是把我们的悬臂移动到特定磁道的特定扇区，也就在这个“几何扇区”里面，找到我们实际的扇区。找到之后，我们的磁头会落下，就可以读取到正对着扇区的数据。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5g31keisj30zs0hqaaw.jpg)

所以，我们进行一次硬盘上的随机访问，需要的时间由两个部分组成。

- **平均时延**(Average Lateency)

  这个时间，其实就是把我们的盘面旋转，把几何扇区对准悬臂位置的时间。这个时间很容易计算，它其实就和我们机械硬盘的转速相关。随机情况下，平均找到一个几何扇区，我们需要旋转半圈盘面。上面 7200 转的硬盘，那么一秒里面，就可以旋转 240 个半圈。那么，这个平均延时就是 *1s / 240 = 4.17ms*

- **平均寻道时间**(Average Seek Time)

  就是在盘面选转之后，我们的悬臂定位到扇区的的时间。我们现在用的 HDD 硬盘的平均寻道时间一般在 4-10ms。

这样，我们就能够算出来，如果随机在整个硬盘上找一个数据，需要 8-14 ms。我们的硬盘是机械结构的，只有一个电机转轴，也只有一个悬臂，所以我们没有办法并行地去定位或者读取数据。那一块 7200 转的硬盘，我们一秒钟随机的 IO 访问次数，也就是*1s / 8 ms = 125 IOPS 或者 1s / 14ms = 70 IOPS*

在顺序读写的场景下，我们只需要旋转一次盘面，进行一次寻道，就可以去写入或者读取同一个垂直空间上的多个盘面的数据。如果一个柱面上的数据不够，也不需要去动悬臂，而是通过电机转动盘面，这样就可以顺序读完一个磁道上的所有数据。

## SSD

SSD 没有像机械硬盘那样的寻道过程，所以随机读写都更快。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5igjvk2bj319q0me0v3.jpg)

### SLC、MLC、TLC、QLC

能够记录一个比特很容易理解。给电容里面充上电有电压的时候就是 1，给电容放电里面没有电就是 0。采用这样方式存储数据的 SSD 硬盘，我们一般称之为使用了 SLC 的颗粒，全称是 Single-Level Cell，也就是一个存储单元只有一位数据。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5inxvvxlj315k0twjsh.jpg)

但是，这样的方式会遇到和 CPU Cache 类似的问题，那就是，同样的面积下，能够存放下的元器件是有限的。如果只用 SLC，我们就会遇到，存储容量上不去，并且价格下不来的问题。于是呢，硬件工程师们就陆续发明了 **MLC(Multi-Level Cell)**、**TLC(Tripe-Level Cell)**以及 **QLC(Quad-Level Cell)**，也就是能在一个电容里存放 2 个、3 个乃至 4 个比特。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb5ir9h555j31vy0td0v1.jpg)

只有一个电容，我们怎么能够表示更多的比特呢？别忘了，这里我们还有一个电压计。4 个比特一共可以从 0000-1111 表示 16 个不同的数。那么，如果我们能往电容里面充电的时候，充上 15 个不同的电压，并且我们电压计能够区分出这 15 个不同的电压。加上电容被放空代表的 0，就能够代表从 0000-1111 这样 4 个比特了。

不过，要想表示 15 个不同的电压，充电和读取的时候，对于精度的要求就会更高。这会导致充电和读取的时候都更慢，所以 QLC 的 SSD 的读写速度，要比 SLC 的慢上好几倍。

### P/E 擦写问题

SSD 硬盘的硬件构造，如下所示：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb6bk9xvhoj30y20jw403.jpg)

首先，和其他的 I/O 设备一样，有对应的接口和控制电路。现在的 SSD 硬盘用的是 STAT 或者 PCI Express 接口。在控制电路中，有一个核心模块叫作 FTL(Flash-Translation Layer)，也就是闪存转换层，SSD 硬盘的好坏，很大程度上也取决于 FTL 的算法好不好。

接下来是实际的 I/O 设备，它是由很多个**裸片**(Die)叠在一起组成的。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb6bp1egoej30zy0u0dn5.jpg)

一张裸片上可以放多个**平面**(Plane)，一般一个平面上的存储容量大概在 GB 级别。一个平面上，会划分很多个**块**(Block)，块的存储大小通常在几百 KB 到几 MB 大小。一个块里面，还会分成很多个**页**(Page)，就和内存里面的页一样，一个页大小通常是 4KB。

对于 SSD 硬盘来说，数据的写入叫做 Program。写入之前要先**擦除**(Erase)，然后再写入。

**SSD 的读取和写入的基本单位，不是一个比特(bit)或者一个字节(byte)，而是一个页(Page)。SSD的擦除的基本单位是块(block)。**

SSD 的使用寿命，是每一个块的擦除的次数。

### SSD 读写的生命周期

下图用三种颜色分别表示 SSD 因公安里面的页的不同状态，白色代表这个页从来没有写入过数据，绿色代表写入的是有效数据，红色代表里面的数据在我们的操作系统来看已经删除了。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb6c55re5ij30u01lgapo.jpg)

可以看到，在实际使用过程中，会存在一些红色空洞，这也导致我们的 SSD 硬盘是用不满的，因此，生产 SSD 硬盘的厂商，其实是预留了一部分空间，专门用来做这个磁盘碎片整理工作的。一块标成 240G 的 SSD 硬盘，往往实际有 256G 的硬盘空间。SSD 硬盘通过我们的控制芯片电路，把多出来的硬盘空间，用来进行各种数据的闪转腾挪，让你能够写满那 240G 的空间。这个多出来的 16G 空间，叫作**预留空间**(Over Provisioning)，一盘 SSD的硬盘的预留空间都在 7%~15% 左右。

### FTL 和磨损均衡

由于频繁的修改文件（比如日常代码开发，我们就会不断地添加新的代码文件，还会不断修改已有的代码文件），在这个过程中，其实是在反复的写入新文件，再把原来的文件标记成逻辑删除的状态。等 SSD 里面空的块少了，就会用“垃圾回收”的方式，惊醒擦除。这样，我们的擦除会反复发生在用来存放这些数据的地方。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb6dz0gfx6j31by0iawfy.jpg)

假如这些块的擦除次数到了上限，就会变成坏块，表现出来的就是硬盘的可用容量变少了。

那么有没有什么办法不让坏块出现的那么早呢？

其中一个办法是**磨损均衡**(Wear-Leveling)，该策略目的是让 SSD 硬盘各个块的擦除次数均匀分摊到各个块上。实现这个技术的核心办法，和虚拟内存一样，添加一个间接层，即 **FTL(闪存转换层)**

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb6e32ki5jj31hs0myju6.jpg)

在 FTL 里，存放了**逻辑块地址**(Logical Block Address, 简称 LBA)到**物理块地址**(Physical Block Address, 简称 PBA)的映射。

操作系统访问的硬盘地址，其实都是逻辑地址。只有通过 FTL 转换之后，才会变成实际的物理地址，找到对应的块进行访问。操作系统本身，不需要去考虑块的磨损程度，只要和操作机械硬盘一样来读写数据就好了。

操作系统所有对于 SSD 硬盘的读写请求，都要经过 FTL。FTL 里面又有逻辑块对应的物理块，所以 FTL 能够记录下来，每个物理块被擦写的次数。如果一个物理块被擦写的次数多了，FTL 就可以将这个物理块，挪到一个擦写次数少的物理块上。但是，逻辑块不用变，操作系统也不需要知道这个变化。

### TRIM 指令

不过，操作系统不去关心实际底层的硬件是什么，在 SSD 硬盘的使用上，也会带来一个问题。这个问题就是，操作系统的逻辑层和 SSD 的逻辑层里的块状态，是不匹配的。

我们在操作系统里面去删除一个文件，其实并没有真的在物理层面去删除这个文件，只是在文件系统里面，把对应的 inode 里面的元信息清理掉，这代表这个 inode 还可以继续使用，可以写入新的数据。这个时候，实际物理层面的对应的存储空间，在操作系统里面被标记成可以写入了。所以，其实我们日常删除文件，只是一个操作系统层面的逻辑删除，这也是为什么，很多时候不小心删除了文件，仍然可以通过各种恢复软件把数据找回来。

这个删除的逻辑在机械硬盘层面没有问题，因为文件被标记成可以写入，后续的写入可以直接覆写这个位置。但是，在 SSD 硬盘上就不一样了。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb6e8osfu3j31sk0u0tfw.jpg)

当在操作系统层面删除了一个文件，在 SSD 的逻辑块层面，并不知道这个删除操作。所以在逻辑块层面，被删除的文件仍然占用了对应的空间。这个时候如果需要对 SSD 进行垃圾回收操作，被删除的文件对应的屋里也，仍然要在这个过程中被搬运到其他的 Block 里面去。只有当操作系统再次在刚才的 inode 里面写入数据的时候，逻辑块层面才会把它标记成已删除。

所以，在使用 SSD 的硬盘情况下，你会发现，操作系统对于文件的删除，SSD 硬盘其实并不知道。这就导致，我们为了磨损均衡，很多时候在都在搬运很多已经删除了的数据。这就会产生很多不必要的数据读写和擦除，既消耗了 SSD 的性能，也缩短了 SSD 的使用寿命。

为了解决这个问题，现在的操作系统和 SSD 的主控芯片，都支持 **TRIM 命令**。*这个命令可以在文件被删除的时候，让操作系统去通知 SSD 硬盘，对应的逻辑块已经标记成已删除了*。现在的 SSD 硬盘都已经支持了 TRIM 命令。无论是 Linux、Windows 还是 MacOS，这些操作系统也都已经支持了 TRIM 命令了。

### 总结

SSD 硬盘的使用寿命受限于可以擦除的次数，因此它特别适合读多写少的场景。在日常应用里，系统盘适合用 SSD，但是如果用 SSD 做专门的下载盘就不太合适。

SSD 硬盘的物理构造由裸片、平面、块、页构成。我们对于数据的写入，只能是一页一页的，不能对页进行覆写。对于数据的擦除，只能整块进行。所以，我们需要用一个，类似“磁盘碎片整理”或者“内存垃圾回收”这样的机制，来清理块当中的数据空洞。而 SSD 硬盘也会保留一定的预留空间，避免出现硬盘无法写满的情况。

现在大家用的 SSD 的存储硬件是 NAND Flash。实现原理是通过改变电压，让电子进入绝缘层的浮栅(Floating Gate)内，断电之后，电子仍在 FG 里。但是如果长时间不通电，比如几年，仍然可能会丢失数据。