# 分布式协议

## CAP

### CAP 理论

一个分布式系统最多只能同时满足**一致性(Consistency)**、**可用性(Availablity)**和**分区容错性(Partition tolerance)**这三项中的两项。

#### 一致性 Consistency

一致性指 `all nodes see the same data at the same time`，即所有节点在同一时间的数据完全一致。

一致性是因为多个数据拷贝下并发读写才有的问题，因此理解时一定要注意结合考虑多个数据拷贝下并发读写的场景。

**从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题；从服务端来看，则是更新如何分布到整个系统，以保持数据一致。**

对于一致性，可以分为强一致性、弱一致性和最终一致性。

- 强一致性

  对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性；

- 弱一致性

  如果能容忍后续的部分或者全部访问不到，则是弱一致性；

- 最终一致性

  如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。

#### 可用性 Availablity

可用性指 `Reads and writes always succeed`，即服务在正常响应时间内一直可用。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。

#### 分区容错 Partition Tolerance

分区容错性指 `the system continues to operate despite arbitrary message loss or failure of part of the system`，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。



### CAP 不可能三角

CAP 不可能三角说的是对于一个分布式系统而言，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）3 个指标不可兼得，只能在 3 个指标中选择 2 个。

<img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbul0hycu2j30vq0pbn2j.jpg" style="zoom: 33%;" />

只要有网络交互就一定会有延迟和数据丢失，而这种状况我们必须接受，还必须保证系统不能挂掉。节点间的分区故障是必然发生的。也就是说，分区容错性（P）是前提，是必须要保证的。

现在就只剩下一致性（C）和可用性（A）可以选择了：要么选择一致性，保证数据绝对一致；要么选择可用性，保证服务可用。

- **CA 模型** CA 满足数据的一致性和高可用性，但没有可扩展性。如传统的单节点关系型数据库 ORACLE、MYSQL ，就是满足数据的一致性和高可用性；

- **CP 模型** 当选择了一致性（C）的时候，如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的写请求时，因为无法保证所有节点都是最新信息，所以系统将返回写失败错误，也就是说集群拒绝新数据写入。典型的应用是 Zookeeper、Etcd 和 HBase；
- **AP 模型** 当选择了可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。典型的应用是 Cassandra 和 DynamoDB。



## ACID 理论

### Atomicity 原子性

整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

### Consistency 一致性

一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。

### Isolation 隔离性

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

### Durability 持久性

在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。



## BASE 理论

BASE 理论是指：`Basically Available（基本可用）`、`Soft-state（ 软状态/柔性事务）`、`Eventual Consistency（最终一致性）`。它是基于 CAP 定理演化而来，是对 CAP 中一致性和可用性权衡的结果。

### 基本可用

指分布式系统在出现故障的时候，允许损失部分可用性，保证核心可用。但不等价于不可用。比如：搜索引擎0.5秒返回查询结果，但由于故障，2秒响应查询结果；网页访问过大时，部分用户提供降级服务等。

#### 如何实现基本可用？

以 12306 订票系统基本可用的设计为例，在春运期间，通过在不同的时间出售不同区域的票，来讲海量的访问请求错开。这就是常说的**流量削峰**。

另外，在春运期间，用户提交的购票请求，往往会在队列中排队等待处理，可能过几分钟后系统才开始处理，然后影响处理结果。这就是**延迟响应**（或者说是**异步处理**）。

再比如，你正负责一个互联网系统，突然出现了网络热点事件，好多用户涌进来，产生了海量的突发流量，系统过载了，大量图片因为网络超时无法显示。这时候我们可以用小图片来替代原始图片，通过降低图片的清晰度和大小，来提升系统的处理能力。这就是**体验降级**。

我们也可以将接收到的请求放在置顶的队列中排队处理，如果请求等待时间超时了（假设是 100ms），就直接拒绝该请求；再比如队列满了之后，就清除队列中一定数量的排队请求，保证系统不过载。这就是**过载保护**。

> 基本可用在本质上是一种妥协，也就是在出现节点故障或系统过载的时候，通过牺牲非核心功能的可用性，保障核心功能的稳定运行。

### 软状态

软状态是指允许系统存在中间状态，并且该中间状态不会影响系统整体可用性。即允许系统在不同节点间副本同步的时候存在延时。

### 最终一致性

系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。

几乎所有的互联网系统采用的都是最终一致性，只有在实在无法使用最终一致性，才使用强一致性或事务，比如，对于决定系统运行的敏感元数据，需要考虑采用强一致性，对于与钱有关的支付系统或金融系统的数据，需要考虑采用事务。

#### 如何实现最终一致性？

- **读时修复** 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据；
- **写时修复** 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性；
- **异步修复** 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。

写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，所以推荐在实现最终一致性时优先实现这种方式。而读时修复和异步修复因为需要做数据的一致性对比，性能消耗比较多，在开发实际系统时，要尽量优化一致性对比的算法，降低性能消耗，避免对系统运行造成影响。



>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它来源于对大规模互联网分布式系统实践的总结，是基于 CAP 定理逐步演化而来的。它的核心思想是，如果不是必须的话，不推荐实现事务或强一致性，鼓励可用性和性能优先，根据业务的场景特点，来实现非常弹性的基本可用，以及实现数据的最终一致性。
>
>BASE 理论主张通过牺牲部分功能的可用性，实现整体的基本可用，也就是说，通过服务降级的方式，努力保障极端情况下的系统可用性。

ACID 理论是传统数据库常用的设计理念，追求强一致性模型。BASE 理论支持的是大型分布式系统，通过牺牲强一致性获得高可用性。BASE 理论在很大程度上，解决了事务型系统在性能、容错、可用性等方面痛点。