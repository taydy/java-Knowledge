# 传输层

传输层里比较重要的两个协议，一个是 **TCP**，一个是 **UDP**。

**TCP 提供可靠交付**。通过 TCP 连接传输的数据，无差错、不丢失、不重复并且按序到达。而 **UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达**。

**TCP 是面向字节流的**。发送的时候发的是一个二进制流，没头没尾。而 **UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收**。

**TCP 是可以有拥塞控制的**。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。**UDP 就不会，应用让我发，我就发，管它洪水滔天。**

因而 **TCP 其实是一个有状态服务**，精确记录着发送了没有，接收到没有，发送到哪儿，应该接受哪个了。而 **UDP 则是无状态服务**。

## UDP

UDP 包格式如下所示：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbadtoq1n5j30tz09fjs1.jpg)

UDP 有以下主要使用场景：

- 需要资源少，在网络比较好的内网或者对于丢包不敏感的应用；
- 不需要一对一沟通，建立连接，而是可以广播的应用；
- 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。

## TCP

TCP 头格式如下所示：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbadzzcyuxj30um0fljta.jpg)

首先，**源端口号和目标端口号**是不可少的，这一点和 UDP 是一样的。如果没有这两个端口号。数据就不知道应该发给哪个应用。

**序号是为了解决乱序的问题**。**确认序号是为了解决丢包的问题**。

TCP 是靠谱的协议，但是这不能说明它面临的网络环境好。从 IP 层面来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而作为 IP 的上一层 TCP 也无能为力，唯一能做的就是更加努力，不断重传，通过各种算法保证。也就是说，对于 TCP 来讲，IP 层你丢不丢包，我管不着，但是我在我的层面上，会努力保证可靠性。

接下来是一些状态位。例如 **SYN 是发起一个连接**，**ACK 是回复**，**RST 是重新连接**，**FIN 是结束连接**。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，也别发的太慢。

### 三次握手

TCP 的连接建立就是我们常常说的三次握手。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbaf380d46j30ep08yq3r.jpg)

一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。

三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是 **TCP 包的序号问题**。A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。

*例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。*

### 四次挥手

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbaf72ighij30fd0d93zs.jpg)

TCP 连接终止时，主机 1 先发送 FIN 报文，主机 2 进入 CLOSE_WAIT 状态，并发送一个 ACK 应答，同时，主机 2 通过 read 调用获得 EOF，并将此结果通知应用程序进行主动关闭操作，发送 FIN 报文。主机 1 在接收到 FIN 报文后发送 ACK 应答，此时主机 1 进入 TIME_WAIT 状态。

主机 1 在 TIME_WAIT 停留持续时间是固定的，是最长分节生命期 MSL（maximum segment lifetime）的两倍，一般称之为 2MSL。**2MSL 是从主机 1 接收到 FIN 后发送 ACK 开始计时的**。 和大多数 BSD 派生的系统一样，Linux 系统里有一个硬编码的字段，名称为 TCP_TIMEWAIT_LEN，其值为 60 秒。也就是说，**Linux 系统停留在 TIME_WAIT 的时间固定为 60 秒**。

**只有发起连接终止的一方会进入 TIME_WAIT 状态**



#### TIME_WAIT 有两点作用

1. 为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；
2. 为了让旧连接的重复节点在网络中自然消失。

#### TIME_WAIT 的危害：

1. 内存资源占用，这个目前看来不是太严重，可以忽略；
2. 对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。端口资源也是有限的，一般可以开启的端口为 32768~61000，也可以通过 `net.ipv4.ip_local_port_range` 指定，如果 TIME_WAIT 状态太多，会导致无法创建新连接。

#### 如何优化 TIME_WAIT ?

Linux 系统对于`net.ipv4.tcp_tw_reuse`的解释如下：

> Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technical experts.

这段话的大意是从协议角度理解如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用。

那么什么是协议角度理解的安全可控呢？主要有两点：

1. 只适用于连接发起方（C/S 模型中的客户端）；
2. 对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用。

使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即 `net.ipv4.tcp_timestamps=1` (默认即为 1)。

要知道，TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。





