# 路由协议

路由器就是一台网络设备，有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为 **路由表**。

一张路由表中会有多条路由规则，每一条规则至少包含三项信息：

- **目的网络** 这个包想去哪儿
- **出口设备** 将包从哪个口扔出去
- **下一条网关** 下一个路由器的地址

通过 route 命令和 ip route 命令都可以进行查询或者配置。

例如，我们设置 `ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0`，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。

## 如何配置策略路由

在真实的复杂的网络环境中，除了可以根据 IP 地址配置路由外，还可以根据多个参数来配置路由，这就称为**策略路由**。

也可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。

```lua
## 从 192.168.1.0/24 网段来的，使用 table 10 中的路由表
ip rule add from 192.168.1.0/24 table 10 
## 从 192.168.2.0/24 网段来的，使用 table 20 中的路由表
ip rule add from 192.168.2.0/24 table 20
```

在一条路由规则中，也可以走多条路径。

```lua
## 下一条有两个地方，分别是 100.100.100.1 和 200.200.200.1, 权重分别为 1 比 2
ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
```

## 动态路由算法

使用动态路由算法，可以根据路由协议生成动态路由表，随网络运行状况的变化而变化。

这里的动态生成路由表其实就是如何在众多路由中找最短路径的问题。

在大学里面学习计算机网络与数据结构的时候，知道求最短路径常用的有两种方法，一种是 Bellman-Ford 算法，一种是 Dijkstra 算法。在计算机网络中基本也是用这两种方法计算的。

1. 距离矢量路由算法

   第一大类的算法称为**距离矢量路由(distance vector routing)**。它是基于 Bellman-Ford 算法的。

   这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。

   由此可以看出，每个路由器都是知道全局信息的。那这个信息如何更新呢？每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。

   每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。

   这个算法比较简单，但是还是有问题。

   **第一个问题就是好消息传得快，换消息传的慢。** 如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去。要不了多久，整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。

   <img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gba831xl4xj30id0ssgoh.jpg" style="zoom: 67%;" />

   **这种算法的第二个问题是，每次发送的时候，要发送整个全局路由表。**网络大了，谁也受不了，所以最早的路由协议 RIP 就是这个算法。它适用于小型网络（小于 15 跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了。

2. 链路状态路由算法

   第二大类算法是**链路状态路由(Link State Routing)**，基于 Dijkstra 算法。

   这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。

   不像距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。



### 基于链路状态路由算法 OSPF

**OSPF(Open Shortest Path First, 开放式最短路径优先)**是一个基于链路状态路由协议，

广泛应用在数据中心。由于主要用在数据中心内部，用于路由决策，因为被称为**内部网关协议(Interior Gateway Protocol, IGP)**。

内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候 OSPF 可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为**等价路由**。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gba7gw2o3dj30vm08q778.jpg)

有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。

一般应用的接入层会有负载均衡 LVS。它可以和 OSPF 一起，实现高吞吐量的接入层设计。

### 基于距离矢量路由算法 BGP

外网的路由协议，也即国家之间的，又有所不同。我们称为**外网路由协议(Border Gateway Protocol, BGP)**。

在网络世界，由一个个自制系统 **AS(Autonomous System)**组成。自制系统分几种类型：

- **Stub AS** 对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如个人或者小公司的网络；
- **Multihomed AS** 可能有多个连接到其他的 AS，但是大多数拒绝帮其他的 AS 传输包。例如一些大公司的网络；
- **Transit AS** 有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。

每个自治系统都有边界路由器，通过它和外面的世界建立联系。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gba7pooenvj30v70dvn02.jpg)

**BGP 又分为两类，eBGP 和 iBGP**。自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。

BGP 协议使用的算法是**路径矢量路由协议(path-vector protocol)**。它是距离矢量路由协议的升级版。

前面说了距离矢量路由协议的缺点。其中一个是收敛慢。在 BGP 里面，除了下一跳 hop 之外，还包括了自治系统 AS 的路径，从而可以避免坏消息传的慢的问题，也即上面所描述的，B 知道 C 原来能够到达 A，是因为通过自己，一旦自己都到达不了 A 了，就不用假设 C 还能到达 A 了。

另外，在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。