# 应用层

## HTTP 请求

HTTP 请求是基于 TCP 协议的，因此要先建立 TCP 连接(即三次握手)。

目前使用的 HTTP 协议大部分都是 1.1。在 1.1 协议协议里，默认是开启 Keep-Alive 的，这样简历的 TCP 连接，就可以在多次请求中复用。

建立了连接之后，就可以发送 HTTP 请求。

### HTTP 请求的构建

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbb7r3nw27j30hb0a33zb.jpg)

HTTP 的报文大概分为三部分。分别是 **请求行**、**首部**、**正文实体**。

请求行包含请求方法(GET、PUT、POST、DELETE 等)、URL(实际请求的URL)、版本(使用的 HTTP 版本，例如 1.1)。

首部字段保存了一些重要的字段，例如：

- **Accept-Charset** 表示客户端可以接受的字符集，防止传过来的是另外的字符集，从而导致出现乱码；

- **Content-Type** 指正文的格式，例如 `application/json`表示接受 json 返回值；

- **Cache-Control** 用来控制缓存。当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。

  另外，**If-Modified-Since** 也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。

### HTTP 请求的发送

HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。当然，到了 TCP 层，它会把二进制流变成一个的报文段发送给服务器。

在发送给每个报文段的时候，都需要对方有一个回应 ACK，来保证报文可靠地到达了对方。如果没有回应，那么 TCP 这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是 HTTP 这一层不需要知道这一点，因为是 TCP 这一层在埋头苦干。

TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到 IP 头里面，交给 IP 层进行传输。

IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。

网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。

这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包发出去。

目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。

TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。

### HTTP 返回的构建

HTTP 的返回报文也是有一定格式的。这也是基于 HTTP 1.1 的。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbb86hq4eaj30hr09zaaw.jpg)

状态码会反应 HTTP 请求的结果状态。常用状态码如下所示：

| 代码 |             消息              | 描述                                                         |
| :--: | :---------------------------: | :----------------------------------------------------------- |
| 100  |           Continue            | 只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。 |
| 101  |      Switching Protocols      | 服务器切换协议。                                             |
| 200  |              OK               | 请求成功。                                                   |
| 201  |            Created            | 该请求是完整的，并创建一个新的资源。                         |
| 202  |           Accepted            | 该请求被接受处理，但是该处理是不完整的。                     |
| 203  | Non-authoritative Information | 暂无                                                         |
| 204  |          No Content           | 暂无                                                         |
| 205  |         Reset Content         | 暂无                                                         |
| 206  |        Partial Content        | 暂无                                                         |
| 300  |       Multiple Choices        | 链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。 |
| 301  |       Moved Permanently       | 所请求的页面已经转移到一个新的 URL。                         |
| 302  |             Found             | 所请求的页面已经临时转移到一个新的 URL。                     |
| 303  |           See Other           | 所请求的页面可以在另一个不同的 URL 下被找到。                |
| 304  |         Not Modified          | 暂无                                                         |
| 305  |           Use Proxy           | 暂无                                                         |
| 306  |            Unused             | 在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。 |
| 307  |      Temporary Redirect       | 所请求的页面已经临时转移到一个新的 URL。                     |
| 400  |          Bad Request          | 服务器不理解请求。                                           |
| 401  |         Unauthorized          | 所请求的页面需要用户名和密码。                               |
| 402  |       Payment Required        | 您还不能使用该代码。                                         |
| 403  |           Forbidden           | 禁止访问所请求的页面。                                       |
| 404  |           Not Found           | 服务器无法找到所请求的页面。.                                |
| 405  |      Method Not Allowed       | 在请求中指定的方法是不允许的。                               |
| 406  |        Not Acceptable         | 服务器只生成一个不被客户端接受的响应。                       |
| 407  | Proxy Authentication Required | 在请求送达之前，您必须使用代理服务器的验证。                 |
| 408  |        Request Timeout        | 请求需要的时间比服务器能够等待的时间长，超时。               |
| 409  |           Conflict            | 请求因为冲突无法完成。                                       |
| 410  |             Gone              | 所请求的页面不再可用。                                       |
| 411  |        Length Required        | "Content-Length" 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。 |
| 412  |      Precondition Failed      | 请求中给出的先决条件被服务器评估为 false。                   |
| 413  |   Request Entity Too Large    | 服务器不接受该请求，因为请求实体过大。                       |
| 414  |     Request-url Too Long      | 服务器不接受该请求，因为 URL 太长。当您转换一个 "post" 请求为一个带有长的查询信息的 "get" 请求时发生。 |
| 415  |    Unsupported Media Type     | 服务器不接受该请求，因为媒体类型不被支持。                   |
| 417  |      Expectation Failed       | 暂无                                                         |
| 500  |     Internal Server Error     | 未完成的请求。服务器遇到了一个意外的情况。                   |
| 501  |        Not Implemented        | 未完成的请求。服务器不支持所需的功能。                       |
| 502  |          Bad Gateway          | 未完成的请求。服务器从上游服务器收到无效响应。               |
| 503  |      Service Unavailable      | 未完成的请求。服务器暂时超载或死机。                         |
| 504  |        Gateway Timeout        | 网关超时。                                                   |
| 505  |  HTTP Version Not Supported   | 服务器不支持"HTTP协议"版本。                                 |



构造好了返回的 HTTP 报文，接下来就是把这个报文发送出去。还是交给 Socket 去发送，还是交给 TCP 层，让 TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达。

这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。

客户端发现 MAC 地址符合、IP 地址符合，于是就会交给 TCP 层。根据序列号看是不是自己要的报文段，如果是，则会根据 TCP 头中的端口号，发给相应的进程。

这就是一个正常的 HTTP 请求和返回的完整过程。

### HTTP 2.0

HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。

为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key  value 在两端建立一个索引表，对相同的头只发送索引表中的索引。

另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。

HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有 **Hearer 帧**，用于传输 Header 内容，并且会开启一个新的流。再就是 **Data 帧**，用来传输正文实体。多个 Data 帧属于同一个流。

通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。



举一个例子。

假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8ieikzgj30i70fygnj.jpg)

HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8j124hpj311p0j377n.jpg)

HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。







